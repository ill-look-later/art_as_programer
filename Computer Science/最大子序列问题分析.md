# 最大子序列问题分析

很久以前也听说过这个问题， 但是一直也没看算法分析相关的书籍（ps：非科班出生还是有些知识面的欠缺...）所以也不知道有这么几种算法的区别， 更不用说分析他们之间那巨大的差异了；所以这次看完后，表示很惊讶；


最大子序列问题应该算是算法分析中一个经典案例；假定存在整数数列 A1, A2, A3, ..... , A<sub>2</sub>; 找出其中最大之序列之和；

最简单的方法也是最暴力最容易想到的便是暴力破解，就是把每一种情况都尝试一遍，找出最大值；也就是说像下面这样:
![](/Computer Science/img/maxsum_subseques.png)

也就是说首先从A1开始依次求出A1...An(1 <= n <= 10),并找出最大的和；之后在冲A2开始，依次求出A2...An(2<=n<=10)并求出最大值并与之前的比较；
```c
int MaxSubSequenceSum(const int Array[], int size) {
    int maxsum = 0; tmpsum = 0;
    
    for (int i=0; i < size; i++) {
        tmpsum = 0;
        for (int j=i; j < size; j++) {
           tmpsum += Array[j];
           if (tmpsum > maxsum) maxsum = tmpsum; 
        }
    }
    return maxsum;
}
```
上面这种很容易就能看出其时间复杂度为O(N<sup>2</sup>); 为了计算出最大的值， 我们重复了很多次，每个值都访问了多次才能将所有的情况给找出来；

假如我们在前面计算的过程中，能将计算的过程中计算过的利用某种状态保存下来那就可能只需要一次遍历完成，这个问题最优解的确就是这样的一种方法；复杂度度为O(N)；

```c
int MaxSubSequenceSum(const int Array[], int size) {
    int tmpsum = 0, maxsum = 0;
    for (int i = 0; i < size; i++) {
        tmpsum += Array[i];
        if (tmpsum > maxsum)
            maxsum = tmpsum;
        else if (tmpsum < 0)
            tmpsum = 0;
    }
    return maxsum;
}
```

方法2之所以可行， 是因为我们假设最大和的序列为 A<sub>i</sub>...A<sub>j</sub>, 那么可以肯定的是
SUM[A<sub>1</sub>...A<sub>i</sub>] < 0的，否则 SUM[A<sub>i</sub>...A<sub>j</sub>] < SUM[A<sub>i</sub>...A<sub>j</sub>] + SUM[A<sub>1</sub>...A<sub>i</sub>], 那么，假设就不成立了；这也是为什么上面的方法可行的原因所在；




























