# 基本排序算法的小结

基本排序
---
- 冒泡排序
- 选择排序
- 插入排序

改进后的排序
---

- 希尔排序
- 堆排序
- 归并排序


冒泡排序：
---

基本的冒泡排序， 没什么好说的，就是拿出一个元素， 与剩下所有元素比一遍； 比完之后，可以确定的是拿出来的这个元素存储的只的大小就是`最大`或者`最小`的；
依次往下， 比完所有元素就确定了顺序；这是最最最基本的思想， 但这与严格意义上的`冒泡排序`定义中的`两两相临元素依次比较`是冲突的；暂且称之为`野冒泡排序`吧；
```c
  for(i : n) ｛//假设规模为n
    for(i+1 : n) {
       if( > ) { 交换两个数据 }
    } 
 // 实例实现
void BubbleSort_0(int arr[], int size) {//非正规军....
    for(int i=0; i < size-1; i++) {
        for(int j=i+1; j < size; j++) {
            if (arr[i] > arr[j]) {
                int tmp = arr[i];
                arr[i] = arr[j];
                arr[j] = tmp;
            }
        }
    }
}
```
如果按照严格意义上的冒泡排序的数学定义. 该是什么样子的实现呢？这里我们基于int数据的数组实现； 只讨论理解算法的内在， 就不考虑其他类型了，那些在C++中有泛型，运算符重载等等的支持；暂且不论；👀下面的这个`标准实现`
```c
void BubbleSort_1(int arr[], int size) {
    for(int i=0; i < size-1; i++) { //循环1

        /* 这里这个内循环的目标就是将i这个位置的元素要变成它与它右边所有元素中
         * 最小的［假设升序］；那么我们就要从最右端size－1开始，用相邻的两个
         * 元素两两比较；如果左边>右边； 则交换两个元素即可!
         */
        for(int j=size-1; j > i; j--) { //循环2
            if (/*左边*/arr[j-1] > arr[j]/*右边*/) {
                int tmp = arr[j];
                arr[j] = arr[j-1];
                arr[j-1] = tmp;
            }
        }
    }
}
```

优化：
---

考虑这样一种情况； 当`循环2`中的i == (j-1)的时候， 如果i元素（即arr[j-1]）与 arr[j] 不需要交换数据的时候， 我们可以跳过一次`循环1`